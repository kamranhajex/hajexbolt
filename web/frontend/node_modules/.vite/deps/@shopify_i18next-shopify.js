import "./chunk-AC2VUBZ6.js";

// ../../node_modules/@shopify/i18next-shopify/dist/es/utils.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var arr = [];
var each = arr.forEach;
function defaults(obj) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  each.call(args, function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0) {
          obj[prop] = source[prop];
        }
      }
    }
  });
  return obj;
}
function replaceValue(interpolated, pattern, replacement) {
  var _interpolated$props;
  switch (_typeof(interpolated)) {
    case "string": {
      var split = interpolated.split(pattern);
      if (split.length !== 1 && _typeof(replacement) === "object") {
        if (!replacement.key) {
          replacement = _objectSpread(_objectSpread({}, replacement), {}, {
            key: pattern.toString()
          });
        }
        return [split[0], replacement, split[1]].flat();
      }
      return interpolated.replace(pattern, replacement);
    }
    case "object":
      if (Array.isArray(interpolated)) {
        return interpolated.map(function(item) {
          return replaceValue(item, pattern, replacement);
        }).flat();
      }
      if (interpolated !== null && interpolated !== void 0 && (_interpolated$props = interpolated.props) !== null && _interpolated$props !== void 0 && _interpolated$props.children) {
        var newChildren = replaceValue(interpolated.props.children, pattern, replacement);
        if (newChildren !== interpolated.props.children) {
          return _objectSpread(_objectSpread({}, interpolated), {}, {
            props: _objectSpread(_objectSpread({}, interpolated.props), {}, {
              children: newChildren
            })
          });
        }
      }
  }
  return interpolated;
}

// ../../node_modules/@shopify/i18next-shopify/dist/es/index.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof2(key) === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (_typeof2(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function getDefaults() {
  return {};
}
var MUSTACHE_FORMAT = /{{?\s*(\w+)\s*}}?/g;
var ShopifyFormat = function() {
  function ShopifyFormat2(options) {
    _classCallCheck(this, ShopifyFormat2);
    this.type = "i18nFormat";
    this.init(null, options);
  }
  _createClass(ShopifyFormat2, [{
    key: "init",
    value: function init(i18next, options) {
      var i18nextOptions = i18next && i18next.options && i18next.options.i18nFormat || {};
      this.options = defaults(i18nextOptions, options, this.options || {}, getDefaults());
      this.i18next = i18next;
    }
    // Implement custom interpolation logic
    // While i18next and Shopify's format both use the mustache syntax for interpolation,
    // Shopify uses the `ordinal` interpolation for ordinal pluralization, while i18next uses `count`.
    // parse(res, options, lng, ns, key, info)
  }, {
    key: "parse",
    value: function parse(res, options) {
      var matches = res.match(MUSTACHE_FORMAT);
      if (!matches) {
        return res;
      }
      var interpolated = res;
      matches.forEach(function(match) {
        var interpolation_key = match.replace(MUSTACHE_FORMAT, "$1");
        var value = interpolation_key === "ordinal" ? options.count || options.ordinal : options[interpolation_key];
        if (value !== void 0) {
          interpolated = replaceValue(interpolated, match, value);
        }
      });
      return interpolated;
    }
    // Add any other locations that should be searched first for an answer to the lookup
    // Add keys to `finalKeys` in reverse order (e.g., least specific -> most specific)
    // Useful when defining keys for pluralization or other context cases (e.g., grammatical gender)
  }, {
    key: "addLookupKeys",
    value: function addLookupKeys(finalKeys, key, code, ns, options) {
      var needsPluralHandling = Boolean(options.count !== void 0 && typeof options.count !== "string" || typeof options.ordinal === "number");
      if (needsPluralHandling) {
        if (!this.i18next.translator.pluralResolver.shouldUseIntlApi()) {
          throw new Error("Error: The application was unable to use the Intl API. This may be due to a missing or incomplete polyfill.");
        }
        var needsOrdinalHandling = Boolean(options.ordinal || options.ordinal === 0 && options.count === void 0);
        var pluralRule = this.i18next.translator.pluralResolver.getRule(code, _objectSpread2(_objectSpread2({}, options), {}, {
          ordinal: needsOrdinalHandling
        }));
        if (needsOrdinalHandling) {
          var ruleName = pluralRule.select(options.count === void 0 ? options.ordinal : options.count);
          var pluralSuffix = "".concat(this.i18next.options.keySeparator, "ordinal").concat(this.i18next.options.keySeparator).concat(ruleName);
          finalKeys.push(key + pluralSuffix);
        } else {
          var _ruleName = pluralRule.select(options.count);
          if (_ruleName !== "other") {
            var otherSubkey = "".concat(this.i18next.options.keySeparator, "other");
            finalKeys.push(key + otherSubkey);
          }
          var _pluralSuffix = "".concat(this.i18next.options.keySeparator).concat(_ruleName);
          finalKeys.push(key + _pluralSuffix);
          if (options.count === 0) {
            var explicit0Subkey = "".concat(this.i18next.options.keySeparator, "0");
            finalKeys.push(key + explicit0Subkey);
          } else if (options.count === 1) {
            var explicit1Subkey = "".concat(this.i18next.options.keySeparator, "1");
            finalKeys.push(key + explicit1Subkey);
          }
        }
      }
      return finalKeys;
    }
  }]);
  return ShopifyFormat2;
}();
ShopifyFormat.type = "i18nFormat";
var es_default = ShopifyFormat;
export {
  es_default as default
};
//# sourceMappingURL=@shopify_i18next-shopify.js.map
